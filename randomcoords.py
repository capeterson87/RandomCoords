from math import radians, cos, sin, asin, sqrt, pi
import random


class RandomCoords:

    # __init__ magic method for creating a RandomCoords object, some variables have defaults and the units variable has type checking.
    def __init__(self, center: [float, float], diameter: int = 10, units: str = 'km'):

        valid_units = {'m', 'km', 'ft', 'mi'}
        self.center = center
        self.diameter = diameter
        self.units = units

        if self.units not in valid_units:
            raise ValueError("Units must be one of %r." % valid_units)

    # __str__ magic method that may help you understand more about the RandomCoords object you're using.
    def __str__(self):

        return f'Center point: {self.center}\nDiameter ({self.units}): {self.diameter}\nUnits: {self.units}'

    # Public method that calls __generate_coord n number of times. Returns an array of length n containing the output of those calls.
    def generate_coords(self, num_coords: int):

        if num_coords == 0:
            return self.__generate_coord()

        coords_list = []
        for dummy in range(num_coords):
            coords_list.append(self.__generate_coord())

        return coords_list

    # Public method that is similar to generate_coords, but with some different terminology and calls __generate_path instead.
    def generate_paths(self, num_paths: int, num_points_range: (int, int) = (10, 50), circle_radius_range: (int, int) = (15, 25)):

        if num_paths == 0:
            return self.__generate_path(num_points_range=num_points_range, circle_radius_range=circle_radius_range)

        paths_list = []
        for dummy in range(num_paths):
            paths_list.append(self.__generate_path(num_points_range=num_points_range, circle_radius_range=circle_radius_range))

        return paths_list

    # Private method that returns a random coordinate based on the data inside the RandomCoords object.
    def __generate_coord(self):

        if self.units == 'm':
            conversion = 0.001
        elif self.units == 'mi':
            conversion = 1.60934
        elif self.units == 'ft':
            conversion = 0.0003048
        else:
            conversion = 1

        # We have to get really funky with the math here because the earth is not flat (although my crazy uncle might disagree).
        circle_long_position = self.center[0]
        circle_lat_position = self.center[1]
        circle_radius = (self.diameter / 2) * conversion
        random_radians = random.random() * 2 * pi
        random_decimal = sqrt(random.random())
        point_long_position = ((circle_radius / 115) * random_decimal) * cos(random_radians) + circle_long_position
        point_lat_position = ((circle_radius / 95) * random_decimal) * sin(random_radians) + circle_lat_position

        return [point_long_position, point_lat_position]

    # Private method that returns a random path with starting point generated by __generate_coord
    # Subsequent points are created by 'drawing' a teeny tiny semicircle around that point until we've reached the number of points determined at the start of the method call, or until the path exits the object's circle.
    def __generate_path(self, num_points_range: (int, int), circle_radius_range: (int, int)):

        num_points = random.randint(num_points_range[0], num_points_range[1])
        path = [self.__generate_coord()]
        last_angle = random.random() * 2 * pi
        for i in range(num_points):
            if self.units == 'm':
                conversion = 0.001
            elif self.units == 'mi':
                conversion = 1.60934
            elif self.units == 'ft':
                conversion = 0.0003048
            else:
                conversion = 1

            # Kind of similar to the code in __generate_point but a little different because we're generating a new circle small portion of our original circle.
            circle_long_position = path[i][0]
            circle_lat_position = path[i][1]
            circle_radius = ((self.diameter / 2) * conversion) / random.randint(circle_radius_range[0], circle_radius_range[1])
            next_angle = random.random() * 2 * pi
            while abs(next_angle - last_angle) > (0.75 * pi):  # This while loop prevents the next angle from being more than 180 degrees away from the last angle, which creates smoother paths.
                next_angle = random.random() * 2 * pi
            random_decimal = sqrt(random.random())
            point_long_position = ((circle_radius / 115) * random_decimal) * cos(next_angle) + circle_long_position
            point_lat_position = ((circle_radius / 95) * random_decimal) * sin(next_angle) + circle_lat_position

            # If the point we just generated is out of bounds, then exit the loop before adding any more points. Sacrifices some speed for reliability.
            if self.__haversine(point_long_position, point_lat_position, self.center[0], self.center[1]) > self.diameter / 2:
                break

            last_angle = next_angle
            path.append([point_long_position, point_lat_position])

        return path

    # This is a private method used by __generate_path which finds the distance between two points on the surface of a sphere (i.e. the earth). We use this method to ensure that a given point is still within the circle.
    def __haversine(self, lat1: float, lon1: float, lat2: float, lon2: float):

        # Initializing the radius of earth based on units of the RandomCoords object
        if self.units == 'm':
            radius = 6372800
        elif self.units == 'mi':
            radius = 3959.87433
        elif self.units == 'ft':
            radius = 20908136.5
        else:
            radius = 6372.8

        # Basic Haversine formula using python's math library
        lat_diff = radians(lat2 - lat1)
        lon_diff = radians(lon2 - lon1)
        lat1 = radians(lat1)
        lat2 = radians(lat2)

        # That's spherical trigonometry, baby!
        angle = sin(lat_diff / 2) ** 2 + cos(lat1) * cos(lat2) * sin(lon_diff / 2) ** 2
        distance = 2 * asin(sqrt(angle))

        return radius * distance
